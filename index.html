<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="description" content="WebRTC code samples">
    <meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1, maximum-scale=1">
    <meta itemprop="name" content="WebRTC code samples">
    <meta name="mobile-web-app-capable" content="yes">
    <meta id="theme-color" name="theme-color" content="#ffffff">

    <base target="_blank">

    <title>CommCon2024 Podcast</title>
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700" rel="stylesheet" type="text/css">
</head>
  
<body>
    <div id="container">

    <audio id="audio-local" controls autoplay></audio>
      
    <div>
        <span id="errorMsg"></span>
    </div>
    
    <a href="https://github.com/dcd2139/commcon2024"
       title="View source for this page on GitHub" id="viewSource">View source on GitHub</a>

</div>
</body>
  
<script>

/*    
const audio = document.querySelector('audio');

const constraints = window.constraints = {
  audio: true,
  video: false
};

function handleSuccess(stream) {
  const audioTracks = stream.getAudioTracks();
  console.log('Got stream with constraints:', constraints);
  console.log('Using audio device: ' + audioTracks[0].label);
  stream.oninactive = function() {
    console.log('Stream ended');
  };
  window.stream = stream; // make variable available to browser console
  audio.srcObject = stream;
}

function handleError(error) {
  const errorMessage = 'navigator.MediaDevices.getUserMedia error: ' + error.message + ' ' + error.name;
  document.getElementById('errorMsg').innerText = errorMessage;
  console.log(errorMessage);
}

navigator.mediaDevices.getUserMedia(constraints).then(handleSuccess).catch(handleError);*/

 // This is the App ID from the dashboard that identifies this Calls Application.
      // https://dash.cloudflare.com/?to=/:account/calls
      // Note: Calls sessions are limited to interacting with sessions in the same App ID.
      const APP_ID = "9aa2e71582245ce1fd7f9a4c1ec39480";
      // ❗❗❗ DO NOT USE YOUR TOKEN IN THE BROWSER FOR PRODUCTION. It should be kept and used server-side.
      const APP_TOKEN = "ad7a9cda73faaaf66ac43775381c55911af060c329ae237def697d9f2c27d530";
      // We'll use this for authentication when making requests to the Calls API.
      const headers = {
        Authorization: `Bearer ${APP_TOKEN}`,
      };
      const API_BASE = `https://rtc.live.cloudflare.com/v1/apps/${APP_ID}`;
      const localVideo = document.querySelector("video#local");
      const remoteVideo = document.querySelector("video#remote");
      if (
        !(localVideo instanceof HTMLVideoElement) ||
        !(remoteVideo instanceof HTMLVideoElement)
      )
        throw new Error("These should be video elements");

      // get a MediaStream from the user's webcam & mic
      const media = await navigator.mediaDevices.getUserMedia({
        audio: true,
        video: true,
      });
      // show the local feed
      localVideo.srcObject = media;

      // First, we'll establish the "local" Calls session by calling createCallsSession
      // which is defined towards the bottom of this script. This will create an
      // RTCPeerConnection and a Calls session, and connect the two.
      const localSession = await createCallsSession();

      // Next we need to push our audio and video tracks. We will add them to the peer
      // connection using the addTransceiver API which allows us to specify the direction
      const transceivers = media.getTracks().map((track) =>
        localSession.peerConnection.addTransceiver(track, {
          direction: "sendonly",
        }),
      );

      // Now that the peer connection has tracks, the next step is to create and set a
      // new offer as the local description. This offer will contain the new tracks in
      // its session description.
      await localSession.peerConnection.setLocalDescription(
        await localSession.peerConnection.createOffer(),
      );

      // Send the local session description to the Calls API, it will
      // respond with an answer and trackIds.
      const pushTracksResponse = await fetch(
        `${API_BASE}/sessions/${localSession.sessionId}/tracks/new`,
        {
          method: "POST",
          headers,
          body: JSON.stringify({
            sessionDescription: {
              sdp: localSession.peerConnection.localDescription?.sdp,
              type: "offer",
            },
            tracks: transceivers.map(({ mid, sender }) => ({
              location: "local",
              mid,
              trackName: sender.track?.id,
            })),
          }),
        },
      ).then((res) => res.json());

      // We take the answer we got from the Calls API and set it as the
      // peer connection's remote description.
      await localSession.peerConnection.setRemoteDescription(
        new RTCSessionDescription(pushTracksResponse.sessionDescription),
      );

      // 🌀🌀🌀
      // At this point, we're done with the sending "local" side, and
      // can now pretend that we're in a completely different browser
      // tab to receive on the "remote" side, and have received the
      // session id and track information to pull via some signalling
      // method such as WebSockets.
      const localSessionId = localSession.sessionId;
      const tracksToPull = transceivers.map(({ sender }) => ({
        location: "remote",
        trackName: sender.track?.id,
        sessionId: localSessionId,
      }));

      console.log(JSON.stringify(tracksToPull));

      // Let's create the remoteSession now to pull the tracks
      const remoteSession = await createCallsSession();

      // We're going to modify the remote session and pull these tracks
      // by requesting an offer from the Calls API with the tracks we
      // want to pull.
      const pullResponse = await fetch(
        `${API_BASE}/sessions/${remoteSession.sessionId}/tracks/new`,
        {
          method: "POST",
          headers,
          body: JSON.stringify({
            tracks: tracksToPull,
          }),
        },
      ).then((res) => res.json());

      // We set up this promise before updating local and remote descriptions
      // so the "track" event listeners are already in place before they fire.
      const resolvingTracks = Promise.all(
        pullResponse.tracks.map(
          ({ mid }) =>
            // This will resolve when the track for the corresponding mid is added.
            new Promise((res, rej) => {
              setTimeout(rej, 5000);
              const handleTrack = ({ transceiver, track }) => {
                if (transceiver.mid !== mid) return;
                remoteSession.peerConnection.removeEventListener(
                  "track",
                  handleTrack,
                );
                res(track);
              };
              remoteSession.peerConnection.addEventListener(
                "track",
                handleTrack,
              );
            }),
        ),
      );

      // Handle renegotiation, this will always be true when pulling tracks
      if (pullResponse.requiresImmediateRenegotiation) {
        // We got a session description from the remote in the response,
        // we need to set it as the remote description
        remoteSession.peerConnection.setRemoteDescription(
          pullResponse.sessionDescription,
        );
        // Create and set the answer as local description
        await remoteSession.peerConnection.setLocalDescription(
          await remoteSession.peerConnection.createAnswer(),
        );
        // Send our answer back to the Calls API
        const renegotiateResponse = await fetch(
          `${API_BASE}/sessions/${remoteSession.sessionId}/renegotiate`,
          {
            method: "PUT",
            headers,
            body: JSON.stringify({
              sessionDescription: {
                sdp: remoteSession.peerConnection.currentLocalDescription?.sdp,
                type: "answer",
              },
            }),
          },
        ).then((res) => res.json());
        if (renegotiateResponse.errorCode) {
          throw new Error(renegotiateResponse.errorDescription);
        }
      }

      // Now we wait for the tracks to resolve
      const pulledTracks = await resolvingTracks;

      // Lastly, we set them in the remoteVideo to display
      const remoteVideoStream = new MediaStream();
      remoteVideo.srcObject = remoteVideoStream;
      pulledTracks.forEach((t) => remoteVideoStream.addTrack(t));

      // ===============================================================
      // THE END — below is the createCallsSession function used above.
      // ===============================================================

      /**
       * Creates a peer connection and connects it to a new Calls session
       */
      async function createCallsSession() {
        const peerConnection = new RTCPeerConnection({
          iceServers: [
            {
              urls: "stun:stun.cloudflare.com:3478",
            },
          ],
          bundlePolicy: "max-bundle",
        });

        // in order for the ICE connection to be established, there must
        // be at least one track present, but since we want each peer
        // connection and session to have tracks explicitly pushed and
        // pulled, we can add an empty audio track here to force the
        // connection to be established.
        peerConnection.addTransceiver("audio", {
          direction: "inactive",
        });

        // create an offer and set it as the local description
        await peerConnection.setLocalDescription(
          await peerConnection.createOffer(),
        );
        const { sessionId, sessionDescription } = await fetch(
          `${API_BASE}/sessions/new`,
          {
            method: "POST",
            headers,
            body: JSON.stringify({
              sessionDescription: peerConnection.localDescription,
            }),
          },
        ).then((res) => res.json());
        const connected = new Promise((res, rej) => {
          // timeout after 5s
          setTimeout(rej, 5000);
          const iceConnectionStateChangeHandler = () => {
            if (peerConnection.iceConnectionState === "connected") {
              peerConnection.removeEventListener(
                "iceconnectionstatechange",
                iceConnectionStateChangeHandler,
              );
              res(undefined);
            }
          };
          peerConnection.addEventListener(
            "iceconnectionstatechange",
            iceConnectionStateChangeHandler,
          );
        });

        // Once both local and remote descriptions are set, the ICE process begins
        await peerConnection.setRemoteDescription(sessionDescription);
        // Wait until the peer connection's iceConnectionState is "connected"
        await connected;
        return {
          peerConnection,
          sessionId,
        };
      }    
  
</script>
</html>
